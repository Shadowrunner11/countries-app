React Router DOM es una librería de react que nos permite hacer apps de una sola página, es decir, páginas webs SPA.
Para usarlo en nuestra app debemos importar la librería:

- npm install react-router-dom --save

Ahora podemos empezar a usarlo. 

Primero veremos lo más sencillo, que es enrutamiento, el cual no es similar a una SPA ya que al solo enrutar la página el contenido tiene que recargar, y eso no es propio de una SPA ya que este consta solo de una página. Para empezar debemos importar de la librería estos módulos 

- BrowserRouter, Routes, Route

Lo primero que debemos hacer es, empezar a usar BrowserRouter en index.js o App.js, para definir que haremos una app de una sola página (un solo html)

App.js: 
 
    import { BrowserRouter, Routes, Route } from 'react-router-dom'

        const App = () => {

            return (

                <BrowserRouter> </BrowserRouter>
            )
        }

        export default App

Ahora que ya tenemos definido que haremos una single page application, debemos usar a Routes, que es el padre de cada path que definamos, es decir, de Route. Al usar Routes estamos diciendo que dentro del mismo vamos a definir las rutas que necesitamos para nuestra app. Entonces declaremosla:

    import { BrowserRouter, Routes, Route } from 'react-router-dom'

        const App = () => {

            return (

                <BrowserRouter> 

                    <Routes>

                    </Routes>

                </BrowserRouter>
            )
        }

    export default App

Ahora si podemos empezar a usar los paths que definamos. Tenemos que usar a Route, en donde este recibe como atributos el path, y el element. El path es la ruta que vamos a definir, y el element es el contenido que se va a mostrar en dicho path, que debe ser contenido JSX. Entonces si yo quiero mostrar un "Hola Mundo" en un h1 cuando ingresemos al path '/about', tendríamos que hacerlo de esta manera:

    import { BrowserRouter, Routes, Route } from 'react-router-dom'

        const App = () => {

            return (

                <BrowserRouter> 

                    <Routes>

                        <Route path='/about' element={ <h4>Hola Mundo<h4/> } />

                    </Routes>

                </BrowserRouter>
            )
        }

    export default App

Entonces si entramos al path /about de nuestra app deberíamos de ver ese Hola Mundo renderizado. Podemos hacer tantos Routes como queramos, solo que debemos definir la ruta y el elemento a renderizar.

Cabe destacar que si queremos renderizar un componente este debe estar en mayúscula, ya que es la forma que React identifica a un componente. Entonces si hacemos renderizado de un componente sería de esta forma: 

componente.js: 

    const ComponentApp = () => {

        return (
            <div>Hola mundo</div>
        )
    }

    export default ComponentApp

App.js: 

    import ComponentApp from './components/ComponentApp'
    import { BrowserRouter, Routes, Route } from 'react-router-dom'

        const App = () => {

            return (

                <BrowserRouter> 

                    <Routes path='/' element={ <ComponentApp /> } >

                    </Routes path='/about' element={ <div>about</div>}>

                </BrowserRouter>
            )
        }

    export default App


Si queremos por ejemplo hacer una página de Not Found, podríamos decir que para todos los paths que no estén en los path ya declarados, queremos renderizar dicho contenido. Eso lo podemos hacer con pasando '*' que en programación hace referencia a todos los elementos, en este caso, path. Pero por buenas prácticas debemos primero realizar todos los paths en el que si creamos contenido, luego englobar a todos los otros que no pusimos y renderizar el contenido de Not Found. Código: 

App.js: 

    import ComponentApp from './components/ComponentApp'
    import { BrowserRouter, Routes, Route } from 'react-router-dom'

        const App = () => {

            return (

                <BrowserRouter> 

                    <Routes path='/' element={ <ComponentApp /> } >

                    </Routes path='/about' element={ <div>about</div>}>

                    </Routes path='*' element={ <div>404 - Not Found</div>}>

                </BrowserRouter>
            )
        }

    export default App


--- Creando navegación SPA ---

Ahora que vimos el enrutamiento, toca ver un problema, los usuarios no pueden navegar solamente a través desde el buscador, deberían poder acceder a un elemento en nuestra app que les permite navegar hacia donde deseen. Para eso React Router DOM ofrece NavLink. Este es un módulo de la librería que simula a una etiqueta ancla de HTML ('a') solo que este al ir hacia la ruta que le pasemos no refresca la página como la etiqueta a de HTML, es decir, internamente tiene incorporada una lógica de .innerHTML para que pueda manipular al DOM, y eso es super cool. Para poder usarlo entonces debemos importarlo de react router dom. 

import {NavLink} from 'react-router-dom'

Y hacer la lógica. Supongamos que queremos ir hacia nuestro componente '/about' que definimos en el enrutamiento. Entonces, en la ruta principal ('/') podemos agregar un NavLink que nos redirija hacia dicho componente, y especificar la ruta con el atributo 'to' que este posee. Ejemplo:

    import {NavLink} from 'react-router-dom'

    const ComponentApp = () => {

        return (

            <>
            <h1>Contenido principal de la página</h1>
            ....
            ....
            <NavLink to='/about'> 
            </>
        )
    }

Entonces eso nos generará en el DOM una etiqueta a, con la diferencia de que su funcionalidad es distinta. Si queremos hacer que este se vea más bien, podemos darle clases css

    import {NavLink} from 'react-router-dom'

    const ComponentApp = () => {

        return (

            <>
            <h1>Contenido principal de la página</h1>
            ....
            ....
            <NavLink to='/about' className='link-about'> 
            </>
        )
    }

Entonces, podemos concluir que Route y NavLink se complementan bastante bien, tienen el poderío de hacer una landing page básica (sin contenido dinámico) completa y con características de las páginas webs actuales